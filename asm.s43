#include "msp430.h"                     ; #define controlled include file
        NAME    main                    ; module name
        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01C00h                  ; start of ram
//PRE-DEFINED VALUES START HERE
; Digits    0     1     2     3     4     5     6     7     8     9
digitH  db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xF7
digitL  db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
; Oper      /     +     -     *
operH   db 0x00, 0x03, 0x03, 0x00
operL   db 0x28, 0x50, 0x00, 0xFA
//PRE-DEFINED VALUES END HERE
        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   mov     #SFE(CSTACK), SP        ; set up stack

main:   nop                             ; main program
        mov     #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down
        ; Enable LCD segments
        mov     #0xffff,&LCDCPCTL0
        mov     #0xfc3f,&LCDCPCTL1
        mov     #0x0fff,&LCDCPCTL2
        
        mov     #0x041e,&LCDCCTL0       ; Initialize LCD_C
        mov     #0x0208,&LCDCVCTL       ; Initialize voltage
        mov     #0x8000,&LCDCCPCTL      ; Clock synchronization enabled
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        bis     #1,&LCDCCTL0            ; Turn LCD on
        bic     #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on by default

setupCalc:
        mov     #0,R5                   ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R6                   ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R7                   ; Represents the third number the
                                        ; user has inputted 
        mov     #0,R8                   ; Represent the state, the program is on
        mov     #0,R9                   ; Used for knowing the number/operation
                                        ; to display next    
        mov     #0,R10                  ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R11                  ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R12                  ; Represents the third number the
                                        ; user has inputted    
        mov     #0,R14                  ; Represents the first full number the
                                        ; user inputted
        mov     #0,R15                  ; Represents the second full number the
                                        ; user inputted
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        call    #displayNumber          ; Display 0 to the user
                   
mainLoop:                               ; The brains of the application
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        cmp     #4,R4                   ; Compare if its the left button
        jeq     pressed                 ; Left button was pressed
        cmp     #2,R4                   ; Compares if its the right button
        jeq     pressed                 ; Right button is pressed
        jnz     mainLoop                ; Keep waiting for user input
    pressed:
        push    R4
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        pop     R4

    checkState:                         ; Checks the state of the application
                                        ; and decide what to do next
        cmp     #3,R8                   ; If state is less than 3 means that the 
        jl      incNumberLoop           ; user is still inputting the number
        jeq     incOperationLoop        ; User is now inputting an operation
        cmp     #7,R8                   ; If state is less than 6 means that the
        jl      incNumberLoop           ; user is still inputting the number 
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000000B,R4           ; Compares if both button are 
                                        ; being pressed
        jeq     setupCalc               ; If true then restart calculator

    incNumberLoop:                      ; Loop for incrementing the number
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     nextNumber              ; If true then increment the number
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     nextState               ; User has decided to input next number
        jmp     mainLoop                ; Keep waiting for user input

    incOperationLoop:                   ; Cycles through the operations
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     nextOperation           ; If true then change the operation
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     operationSelected       ; User has decided the operation, so now
                                        ; we reset to display the next number
        jmp     mainLoop                ; Keep waiting for user input

nextNumber:                             ; Subroutine that increments the number
                                        ; by 1 and circles back to 0
        cmp     #9,R9                   ; Resets the number back to 0 meaning
        jeq     resetNumber             ; the user has accidentaly missed the 
                                        ; desired number
        inc     R9                      ; Increment the number by 1
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input
        
resetNumber:                            ; Resets the number back to 0
        mov     #0,R9                   ; Number is set back to 0
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

nextState:
        push    R9                      ; Save the number in the stack
        mov     #0,R9                   ; Set the number to 0
        inc     R8                      ; Increment to the next state of 
                                        ; the program
        cmp     #3,R8                   ; If the program is on stage 3 then
        jeq     nextOperation           ; now we display the operation 
        cmp     #7,R8                   ; If the program is on stage 3 then the
        jeq     doTheMath               ; user has finish inputting all the data
                                        ; and is now expecting an answer
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

nextOperation:
        cmp     #3,R9                   ; Resets the number back to 0 meaning
        jeq     resetOperation          ; the user has accidentaly missed the 
                                        ; desired operation
        inc     R9                      ; Increment the number by 1
        call    #displayOperation       ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

resetOperation:
        mov     #0,R9                   ; Number is set back to 0
        call    #displayOperation       ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

operationSelected: 
        inc     R8
        push    R9
        mov     #0,R9
        call    #displayNumber          ; Display 0 to the user
        jmp mainLoop

stillHoldDown:
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        and.b   #00000110B,R4           ; Compares which button is being pressed
        cmp.b   #00000100B,R4           ; Left button (P1.1) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        cmp.b   #00000010B,R4           ; Right button (P1.2) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        call    #delay
        ret                             ; User has finally let go of the button

delay:
        mov     #0x2710,R13             ; Represents the delay to wait for
                                        ; button bouncing
    decrement:
        dec     R13                     ; Decrement delay by 1
        jnz     decrement               ; Delay to help combat button bouncing
        ret

doTheMath:
        pop     R12
        pop     R11
        pop     R10
        pop     R9
        pop     R7
        pop     R6
        pop     R5
        call    #combineDigits
        cmp     #1,R9
        jeq     addNumbers
        cmp     #2,R9
        jeq     subNumbers
        cmp     #3,R9
        jeq     mulNumbers
        cmp     #0,R9
        jeq     devNumbers
        jmp     mainLoop

combineDigits:
    firstDigitCombine:      
        ADD.w   #100, R14       ; This subroutine will add 100 to R14 and decrease R5 by one until R5 is 0
        dec     R5
        jnz     firstDigitCombine 
    secondDigitCombine:     
        ADD.w   #10, R14        ; This subroutine will add 10 to R14 and decrease R6 by one until R6 is 0
        dec     R6
        jnz     secondDigitCombine
    thirdDigitCombine:      
        ADD.w   R7, R14         ; This will add the last digit to R14

    firstDigitCombine2:     
        ADD.w   #100, R15       ; This subroutine will add 100 to R15 and decrease R10 by one until R10 is 0
        dec     R10
        jnz     firstDigitCombine2
    secondDigitCombine2:    
        ADD.w   #10, R15        ; This subroutine will add 10 to R15 and decrease R6 by one until R11 is 0
        dec     R11
        jnz     secondDigitCombine2
    thirdDigitCombine2:     
        ADD.w   R12, R15        ; This will add the last digit to R15
        ret

addNumbers:
        add.w   R15,R14         ; Adds numbers saved in R14 and R15 and stores the result in R14
        mov     #0, R15
        call    #seperateDigits
        call    #displayResults
        jmp     mainLoop

mulNumbers:
    multSetup:              
        CMP.w   R14, R15
        JL      multAlgorithm
        CALL    #multSwitchNumbers
    multAlgorithm:          
        MOV     R14, R6
        MOV     R15, R7
        MOV     #0, R15
    multLoop:
        DEC     R7
        jz      multDone
        ADD.w   R6, R14
        CMP.w   #1000, R14
        JGE     multReachedThousand
        jmp     multLoop
    multDone:
        call    #seperateDigits
        call    #displayResults
        jmp     mainLoop

multReachedThousand:
        SUB.w   #1000,R14
        INC     R15
        jmp     multLoop

multSwitchNumbers:
        PUSH.w   R15
        MOV      R14, R15
        POP.w    R14
        RET

subNumbers:
        sub.w   R15, R14                ; R14 = R14 - R15
        call    #seperateDigits
        call    #displayResults
        jmp     mainLoop

devNumbers:
        push.w  R5              ; store value of R5 in stack
        mov.w   #0, R5          ; R5 = quotient = 0   
 
divLoop:          
        sub.w   R15, R14        ; R14 = R14 - R15
        cmp.w   #0, R14         ; compare to see if we can keep subtracting
        jn      divEnd          ; R14 < 0, its negative so we subtracted too much
        inc     R5              ; quotient += 1
        jeq     divEnd          ; R14 == 0, there's nothing left to subtract
        jmp     divLoop         ; keep looping    
   
divEnd:
        inv     R14
        mov.W   R5, R14         ; store result in R14
        pop.w   R5              ; restore value of R5
        call    #seperateDigits
        call    #displayResults
        jmp     mainLoop
        
modDivTen: ; divides R14 by 10 and stores result in R14 and remainder in R9
        push.w  R15             ; push R15 to stack so that we can restore its value later
        mov.w   #0, R9          ; R9 = quotient = 0

    mdtLoop:
        mov.w   R14, R15        ; R15 = remainder = R14
        sub.w   #10, R14        ; R14 = R14 - 10
        cmp.w   #0, R14         ; compare to see if we can keep subtracting
        jn      mdtEnd          ; R14 < 0, its negative so we subtracted too much
        inc     R9              ; quotient += 1
        jeq     mdtEnd          ; R14 == 0, there's nothing left to subtract
        jmp     mdtLoop         ; keep looping   
    
mdtEnd:
        mov.w   R9, R14         ; store result in R14
        mov.w   R15, R9         ; store remainder in R9
        pop.w   R15             ; restore value of R15
        ret

modDivTenMult: ; divides R15 by 10 and stores result in R15 and remainder in R9
        push.w  R14             ; push R14 to stack so that we can restore its value later
        mov.w   #0, R9          ; R9 = quotient = 0

mdtLoopMult:
        mov.w   R15, R14        ; R14 = remainder = R15
        sub.w   #10, R15        ; R15 = R15 - 10
        cmp.w   #0, R15         ; compare to see if we can keep subtracting
        jn      mdtEndMult      ; R15 < 0, its negative so we subtracted too much
        inc     R9              ; quotient += 1
        jeq     mdtEndMult      ; R15 == 0, there's nothing left to subtract
        jmp     mdtLoopMult             ; keep looping     
  
mdtEndMult:
        mov.w   R9, R15         ; store result in R15
        mov.w   R14, R9         ; store remainder in R9
        pop.w   R14             ; restore value of R14
        ret

seperateDigits: ; separeates R14 into its decimal components
        cmp.w   #2, R9          ; Subtraction, always 3 digits, 
        jeq     sepDigSub       ; but sometimes its negative
        cmp.w   #3, R9          ; Multiplication, 3 to 6 digits
        jeq     sepDigMult
        cmp.w   #4, R9          ; Division, always 3 digits
        jeq     threeDigits
                                ; else its Addition, 3 to 4 digits
        cmp.w   #1000, R14      ; R14-1000, if result is positive, 
        jc      fourDigits      ; then R14 has 4 digits
        jmp     threeDigits             ; else, R14 has three digits
        jmp     sepDigEnd      
        
sepDigSub: ; checks if R14 is negative
        push.w  R14             ; store R14 in stack
        and.w   #1000000000000000b, R14 ; apply bit mask
                                ; if most significant bit is 1, then its a negative number
        cmp.w   #0, R14         ; if R14 == 0, then most significant bit is 0
        pop.w   R14             ; restore value of R14
        jeq     threeDigits     ; R14 is a positive number
        jmp     threeDigitsNeg  ; R14 is a negative number
        
threeDigitsNeg: 
        inv     R14             ; convert R14 to positive, first invert everything,
        inc     R14             ; then add 1
        call    #threeDigits
        mov.w   #1, R14         ; add negative flag
        jmp     sepDigEnd
        
threeDigits:
        call    #modDivTen
        mov.w   R9, R5
        call    #modDivTen
        mov.w   R9, R6
        call    #modDivTen
        mov.w   R9, R7
        mov.w   #3, R15         ; store amount of digits in R15
        ret
        
fourDigits:
        call    #threeDigits
        call    #modDivTen
        mov.w   R9, R10
        mov.w   #4, R15         ; store amount of digits in R15
        jmp     sepDigEnd
        
sepDigMult: ; checks how many digits the product has
        cmp.w   #0, R15         ; if R15 is 0, then the product has 3 digits
        jeq     threeDigitsMult   
        cmp.w   #100, R15       ; R15-100, if result has carry, 
        jc      sixDigitsMult   ; then R15 has 6 digits
        cmp.w   #10, R15        ; R15-10, else if result has carry,
        jc      fiveDigitsMult  ; then R15 has 5 digits
        jmp     fourDigitsMult  ; else R15 has 4 digits 

threeDigitsMult:
        call    #modDivTen
        mov.w   R9, R5
        call    #modDivTen
        mov.w   R9, R6
        call    #modDivTen
        mov.w   R9, R7 
        mov.w   #3, R15         ; store amount of digits in R15
        jmp     sepDigEnd
        
fourDigitsMult:
        call    #modDivTen
        mov.w   R9, R5
        call    #modDivTen
        mov.w   R9, R6
        call    #modDivTen
        mov.w   R9, R7
        call    #modDivTenMult
        mov.w   R9, R10
        mov.w   #4, R15          ; store amount of digits in R15
        jmp     sepDigEnd
        
fiveDigitsMult:
        call    #modDivTen
        mov.w   R9, R5
        call    #modDivTen
        mov.w   R9, R6
        call    #modDivTen
        mov.w   R9, R7
        call    #modDivTenMult
        mov.w   R9, R10
        call    #modDivTenMult
        mov.w   R9, R11
        mov.w   #5, R15          ; store amount of digits in R15
        jmp     sepDigEnd
        
sixDigitsMult:
       call    #modDivTen
        mov.w   R9, R5
        call    #modDivTen
        mov.w   R9, R6
        call    #modDivTen
        mov.w   R9, R7
        call    #modDivTenMult
        mov.w   R9, R10
        call    #modDivTenMult
        mov.w   R9, R11
        call    #modDivTenMult
        mov.w   R9, R12
        mov.w   #6, R15          ; store amount of digits in R15
        jmp     sepDigEnd
        
sepDigEnd:
        ret
        
displayResults:
        cmp     #4,R15
        jl      pushFirts3Digits
        jeq     pushFirts4Digits
        cmp     #6,R15
        jl      pushFirts5Digits
        jeq     pushFirts6Digits
    
    pushFirts3Digits:
        push    R5
        push    R6
        push    R7
        jmp     displayNextDigit
        
    pushFirts4Digits:
        push    R5
        push    R6
        push    R7
        push    R10
        jmp     displayNextDigit
        
    pushFirts5Digits:
        push    R5
        push    R6
        push    R7
        push    R10
        push    R11
        jmp     displayNextDigit
        
    pushFirts6Digits:
        push    R5
        push    R6
        push    R7
        push    R10
        push    R11
        push    R12
        jmp     displayNextDigit
        
    displayNextDigit:
        dec     R15
        cmp     #0,R15
        jl      resultsDone
        pop     R9
        cmp     #1,R13                          ; No mores zeros to the left
        jge     noMoreLeftZeros                 ; of the number
        cmp     #0,R9
        jeq     displayNextDigit
    noMoreLeftZeros:
        inc     R13
        cmp     #1,R13
        jeq     displayFirstDigit
        cmp     #2,R13
        jeq     displaySecondDigit
        cmp     #3,R13
        jeq     displayThirdDigit
        cmp     #4,R13
        jeq     displayFourthDigit
        cmp     #5,R13
        jeq     displayFifthDigit
        cmp     #6,R13
        jeq     displaySixthDigit
        
    displayFirstDigit:
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        call    #displayFirstSegment
        cmp     #1,R14
        jeq     displayNegative
        jmp     displayNextDigit
        
    displaySecondDigit:
        call    #displaySecondSegment
        jmp     displayNextDigit
        
    displayThirdDigit:
        call    #displayThirdSegment
        jmp     displayNextDigit
        
    displayFourthDigit:
        call    #displayFourthSegment
        jmp     displayNextDigit  
        
    displayFifthDigit:
        call    #displayFifthSegment
        jmp     displayNextDigit 
        
    displaySixthDigit:
        call    #displaySixthSegment
        jmp     displayNextDigit 
        
    resultsDone:
        ret

displayNegative:
        bis.b   #4,&0x0A29+1
        jmp     displayNextDigit

displayNumber:
        cmp     #0,R8
        jeq     displayFirstSegment
        cmp     #1,R8
        jeq     displaySecondSegment
        cmp     #2,R8
        jeq     displayThirdSegment
        cmp     #3,R8
        jeq     displayOperation
        cmp     #4,R8
        jeq     displayFirstSegment
        cmp     #5,R8
        jeq     displaySecondSegment
        cmp     #6,R8
        jeq     displayThirdSegment
        
displayOperation:
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        mov.b   operH(R9),&0x0A29
        mov.b   operL(R9),&0x0A29+1
        ret
        
displayFirstSegment:
        mov.b   digitH(R9),&0x0A29
        mov.b   digitL(R9),&0x0A29+1
        ret

displaySecondSegment:
        mov.b   digitH(R9),&0x0A25
        mov.b   digitL(R9),&0x0A25+1
        ret

displayThirdSegment:
        mov.b   digitH(R9),&0x0A23
        mov.b   digitL(R9),&0x0A23+1
        ret


displayFourthSegment:
        mov.b   digitH(R9),&0x0A32
        mov.b   digitL(R9),&0x0A32+1
        ret


displayFifthSegment:
        mov.b   digitH(R9),&0x0A2E
        mov.b   digitL(R9),&0x0A2E+1
        ret


displaySixthSegment:
        mov.b   digitH(R9),&0x0A27
        mov.b   digitL(R9),&0x0A27+1
        ret


fin:    JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        END
