#include "msp430.h"                     ; #define controlled include file
        NAME    main                    ; module name
        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01C00h                  ; start of ram
//PRE-DEFINED VALUES START HERE
; Digits    0     1     2     3     4     5     6     7     8     9
digitH  db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xF7
digitL  db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
; Oper      /     +     -     *
operH   db 0x00, 0x03, 0x03, 0x00
operL   db 0x28, 0x50, 0x00, 0xFA
//PRE-DEFINED VALUES END HERE
        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   mov     #SFE(CSTACK), SP        ; set up stack

main:   nop                             ; main program
        mov     #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down
        ; Enable LCD segments
        mov     #0xffff,&LCDCPCTL0
        mov     #0xfc3f,&LCDCPCTL1
        mov     #0x0fff,&LCDCPCTL2
        
        mov     #0x041e,&LCDCCTL0       ; Initialize LCD_C
        mov     #0x0208,&LCDCVCTL       ; Initialize voltage
        mov     #0x8000,&LCDCCPCTL      ; Clock synchronization enabled
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        bis     #1,&LCDCCTL0            ; Turn LCD on
        bic     #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on by default

setupCalc:
        mov     #0,R5                   ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R6                   ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R7                   ; Represents the third number the
                                        ; user has inputted 
        mov     #0,R8                   ; Represent the state, the program is on
        mov     #0,R9                   ; Used for knowing the number/operation
                                        ; to display next    
        mov     #0,R10                  ; Represents the first number the
                                        ; user has inputted 
        mov     #0,R11                  ; Represents the second number the
                                        ; user has inputted 
        mov     #0,R12                  ; Represents the third number the
                                        ; user has inputted    
        mov     #0,R14                  ; Represents the first full number the
                                        ; user inputted
        mov     #0,R15                  ; Represents the second full number the
                                        ; user inputted
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        call    #displayNumber          ; Display 0 to the user
                   
mainLoop:                               ; The brains of the application
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        cmp     #4,R4                   ; Compare if its the left button
        jeq     pressed                 ; Left button was pressed
        cmp     #2,R4                   ; Compares if its the right button
        jeq     pressed                 ; Right button is pressed
        jnz     mainLoop                ; Keep waiting for user input
    pressed:
        push    R4
        call    #delay                  ; Delay to help combat button bouncing
        call    #stillHoldDown          ; Verify if the user is still holding 
                                        ; down the button
        pop     R4

    checkState:                         ; Checks the state of the application
                                        ; and decide what to do next
        cmp     #3,R8                   ; If state is less than 3 means that the 
        jl      incNumberLoop           ; user is still inputting the number
        jeq     incOperationLoop        ; User is now inputting an operation
        cmp     #7,R8                   ; If state is less than 6 means that the
        jl      incNumberLoop           ; user is still inputting the number 
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     setupCalc               ; If true then restart calculator
        cmp.b   #00000000B,R4           ; Compares if both button are 
                                        ; being pressed
        jeq     setupCalc               ; If true then restart calculator

    incNumberLoop:                      ; Loop for incrementing the number
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     nextNumber              ; If true then increment the number
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     nextState               ; User has decided to input next number
        jmp     mainLoop                ; Keep waiting for user input

    incOperationLoop:                   ; Cycles through the operations
        and.b   #00000110B,R4           ; Compares if the left button (P1.1)
        cmp.b   #00000100B,R4           ; is being pressed
        jeq     nextOperation           ; If true then change the operation
        cmp.b   #00000010B,R4           ; Compares if the right button (P1.2)
                                        ; is being pressed
        jeq     operationSelected       ; User has decided the operation, so now
                                        ; we reset to display the next number
        jmp     mainLoop                ; Keep waiting for user input

nextNumber:                             ; Subroutine that increments the number
                                        ; by 1 and circles back to 0
        cmp     #9,R9                   ; Resets the number back to 0 meaning
        jeq     resetNumber             ; the user has accidentaly missed the 
                                        ; desired number
        inc     R9                      ; Increment the number by 1
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input
        
resetNumber:                            ; Resets the number back to 0
        mov     #0,R9                   ; Number is set back to 0
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

nextState:
        push    R9                      ; Save the number in the stack
        mov     #0,R9                   ; Set the number to 0
        inc     R8                      ; Increment to the next state of 
                                        ; the program
        cmp     #3,R8                   ; If the program is on stage 3 then
        jeq     nextOperation           ; now we display the operation 
        cmp     #7,R8                   ; If the program is on stage 3 then the
        jeq     doTheMath               ; user has finish inputting all the data
                                        ; and is now expecting an answer
        call    #displayNumber          ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

nextOperation:
        cmp     #3,R9                   ; Resets the number back to 0 meaning
        jeq     resetOperation          ; the user has accidentaly missed the 
                                        ; desired operation
        inc     R9                      ; Increment the number by 1
        call    #displayOperation       ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

resetOperation:
        mov     #0,R9                   ; Number is set back to 0
        call    #displayOperation       ; Display the new number to the user
        jmp     mainLoop                ; Keep waiting for user input

operationSelected: 
        inc     R8
        push    R9
        mov     #0,R9
        call    #displayNumber          ; Display 0 to the user
        jmp mainLoop

stillHoldDown:
        mov.b   &P1IN,R4                ; Copy into R4 P1IN's byte
        and.b   #00000110B,R4           ; Compares which button is being pressed
        cmp.b   #00000100B,R4           ; Left button (P1.1) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        cmp.b   #00000010B,R4           ; Right button (P1.2) is being pressed
        jeq     stillHoldDown           ; If true wait for user to stop holding 
                                        ; down the button
        call    #delay
        ret                             ; User has finally let go of the button

delay:
        mov     #0x2710,R13             ; Represents the delay to wait for
                                        ; button bouncing
    decrement:
        dec     R13                     ; Decrement delay by 1
        jnz     decrement               ; Delay to help combat button bouncing
        ret

doTheMath:
        pop     R12
        pop     R11
        pop     R10
        pop     R9
        pop     R7
        pop     R6
        pop     R5
        call    #combineDigits
        cmp     #1,R9
        jeq     addNumbers
        cmp     #2,R9
        jeq     subNumbers
        cmp     #3,R9
        jeq     mulNumbers
        cmp     #0,R9
        jeq     devNumbers
        jmp     mainLoop

combineDigits:
    firstDigitCombine:      
        ADD.w   #100, R14       ; This subroutine will add 100 to R14 and decrease R5 by one until R5 is 0
        dec     R5
        jnz     firstDigitCombine 
    secondDigitCombine:     
        ADD.w   #10, R14        ; This subroutine will add 10 to R14 and decrease R6 by one until R6 is 0
        dec     R6
        jnz     secondDigitCombine
    thirdDigitCombine:      
        ADD.w   R7, R14         ; This will add the last digit to R14

    firstDigitCombine2:     
        ADD.w   #100, R15       ; This subroutine will add 100 to R15 and decrease R10 by one until R10 is 0
        dec     R10
        jnz     firstDigitCombine2
    secondDigitCombine2:    
        ADD.w   #10, R15        ; This subroutine will add 10 to R15 and decrease R6 by one until R11 is 0
        dec     R11
        jnz     secondDigitCombine2
    thirdDigitCombine2:     
        ADD.w   R12, R15        ; This will add the last digit to R15
        ret

addNumbers:
        add.w   R15,R14         ; Adds numbers saved in R14 and R15 and stores the result in R14
        MOV     #0, R15
        call    #seperateDigits
        call    #displayResults
        jmp     mainLoop

subNumbers:
        //Sub R14-R15
        call    #seperateDigits
        call    #displayResults
        jmp     mainLoop

mulNumbers:
multSetup:              
        CMP.w   R14, R15
        JN      multAlgorithm
        CALL    #multSwitchNumbers
multAlgorithm:          
        MOV     #0,R5
        MOV     R14, R6
        MOV     R15, R7
        MOV     #0, R15
multLoop:
        DEC     R7
        jz      done
        ADD.w   R6, R14
        CMP.w   #1000, R14
        JGE     multReachedThousand
        jmp     multLoop
multDone:
        call    #seperateDigits
        call    #displayResults
        jmp     mainLoop

multReachedThousand:
        SUB.w   #1000,R14
        INC     R15
        jmp     multLoop

multSwitchNumbers:
        PUSH.w   R15
        MOV      R14, R15
        POP.w    R14
        RET

devNumbers:
        //Div R14/R15
        call    #seperateDigits
        call    #displayResults
        jmp     mainLoop
        
seperateDigits:
        //Missing Code
        ret
        
displayResults:
        //Missing Code
        ret
        
displayNumber:
        cmp     #0,R8
        jeq     displayFirstSegment
        cmp     #1,R8
        jeq     displaySecondSegment
        cmp     #2,R8
        jeq     displayThirdSegment
        cmp     #3,R8
        jeq     displayOperation
        cmp     #4,R8
        jeq     displayFirstSegment
        cmp     #5,R8
        jeq     displaySecondSegment
        cmp     #6,R8
        jeq     displayThirdSegment
        
displayOperation:
        mov     #2,&LCDCMEMCTL          ; Clear LCD memory
        mov.b   operH(R9),&0x0A29
        mov.b   operL(R9),&0x0A29+1
        ret
        
displayFirstSegment:
        mov.b   digitH(R9),&0x0A29
        mov.b   digitL(R9),&0x0A29+1
        ret

displaySecondSegment:
        mov.b   digitH(R9),&0x0A25
        mov.b   digitL(R9),&0x0A25+1
        ret

displayThirdSegment:
        mov.b   digitH(R9),&0x0A23
        mov.b   digitL(R9),&0x0A23+1
        ret


displayFourthSegment:
        mov.b   digitH(R9),&0x0A32
        mov.b   digitL(R9),&0x0A32+1
        ret


displayFifthSegment:
        mov.b   digitH(R9),&0x0A2E
        mov.b   digitL(R9),&0x0A2E+1
        ret


displaySixthSegment:
        mov.b   digitH(R9),&0x0A27
        mov.b   digitL(R9),&0x0A27+1
        ret


fin:    JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        END
